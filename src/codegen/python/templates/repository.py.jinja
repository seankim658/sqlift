"""Repository class for {{ table_name }} table."""

from dataclasses import dataclass
from typing import Any, Literal
{% for imp in imports -%}
{{ imp }}
{% endfor -%}
from psycopg import Connection
from psycopg import sql

from ._types import UNSET, _Unset


_{{ table_name | upper }}_COLUMNS: frozenset[str] = frozenset({
{%- for col in columns %}
    "{{ col.name }}",
{%- endfor %}
})


@dataclass
class {{ record_name }}:
    """Record for {{ table_name }} table."""
{% for col in columns %}
    {{ col.name }}: {{ col.python_type }}
{%- endfor %}


{% if insert_columns -%}
@dataclass
class {{ singular_class_name }}InsertParams:
    """Parameters for inserting a {{ singular_name }} record."""
{%- for col in insert_columns %}
{%- if col.is_nullable %}
    {{ col.name }}: {{ col.python_type }} = None
{%- else %}
    {{ col.name }}: {{ col.python_type }}
{%- endif %}
{%- endfor %}


{% endif -%}
{% if has_pk and non_pk_columns -%}
@dataclass
class {{ singular_class_name }}UpdateParams:
    """Parameters for batch updating a {{ singular_name }} record."""
{%- for col in pk_columns %}
    {{ col.name }}: {{ col.base_type }}
{%- endfor %}
{%- for col in non_pk_columns %}
    {{ col.name }}: {{ col.update_type }} = UNSET
{%- endfor %}


{% endif -%}

class {{ class_name }}Repository:
    """Repository for {{ table_name }} operations."""

    def __init__(self, conn: Connection) -> None:
        self.conn = conn

{% if has_pk %}
    def get_by_{% for col in pk_columns %}{{ col.name }}{% if not loop.last %}_and_{% endif %}{% endfor %}(
        self,
{%- for col in pk_columns %}
        {{ col.name }}: {{ col.base_type }},
{%- endfor %}
    ) -> {{ record_name }} | None:
        """Get a record by primary key."""
        cursor = self.conn.execute(
            "SELECT * FROM {{ table_name }} WHERE {% for col in pk_columns %}{{ col.name }} = %s{% if not loop.last %} AND {% endif %}{% endfor %}",
            ({% for col in pk_columns %}{{ col.name }},{% endfor %}),
        )
        row = cursor.fetchone()
        if row is None:
            return None
        return {{ record_name }}(**dict(row))

{% endif %}
    def get_all(
        self,
        limit: int | None = None,
        offset: int | None = None,
    ) -> list[{{ record_name }}]:
        """Get all records with optional limit/offset pagination."""
        query = "SELECT * FROM {{ table_name }}"
        params: list[Any] = []

        if limit is not None:
            query += " LIMIT %s"
            params.append(limit)
        if offset is not None:
            query += " OFFSET %s"
            params.append(offset)

        cursor = self.conn.execute(query, params)
        rows = cursor.fetchall()
        return [{{ record_name }}(**dict(row)) for row in rows]

{% if has_pk %}
    def get_page(
        self,
        limit: int = 100,
        sort_column: str = "{{ pk_columns[0].name }}",
        sort_direction: Literal["asc", "desc"] = "asc",
        after: Any = None,
    ) -> list[{{ record_name }}]:
        """Get a page of records using cursor-based pagination."""
        if sort_column not in _{{ table_name | upper }}_COLUMNS:
            raise ValueError(
                f"Invalid sort column: {sort_column}. "
                f"Must be one of: {sorted(_{{ table_name | upper }}_COLUMNS)}"
            )

        order = "ASC" if sort_direction == "asc" else "DESC"
        comparator = ">" if sort_direction == "asc" else "<"

        if after is not None:
            query = sql.SQL(
                "SELECT * FROM {{ table_name }} WHERE {} {} %s ORDER BY {} {} LIMIT %s"
            ).format(
                sql.Identifier(sort_column),
                sql.SQL(comparator),
                sql.Identifier(sort_column),
                sql.SQL(order),
            )
            cursor = self.conn.execute(query, (after, limit))
        else:
            query = sql.SQL(
                "SELECT * FROM {{ table_name }} ORDER BY {} {} LIMIT %s"
            ).format(
                sql.Identifier(sort_column),
                sql.SQL(order),
            )
            cursor = self.conn.execute(query, (limit,))

        rows = cursor.fetchall()
        return [{{ record_name }}(**dict(row)) for row in rows]

{% endif %}
    def insert(
        self,
{%- for col in insert_columns %}
{%- if col.is_nullable %}
        {{ col.name }}: {{ col.python_type }} = None,
{%- else %}
        {{ col.name }}: {{ col.python_type }},
{%- endif %}
{%- endfor %}
    ) -> {{ record_name }}:
        """Insert a new record."""
{% if insert_columns %}
        cursor = self.conn.execute(
            """
            INSERT INTO {{ table_name }} ({% for col in insert_columns %}{{ col.name }}{% if not loop.last %}, {% endif %}{% endfor %})
            VALUES ({% for col in insert_columns %}%s{% if not loop.last %}, {% endif %}{% endfor %})
            RETURNING *
            """,
            ({% for col in insert_columns %}{{ col.name }}, {% endfor %}),
        )
{% else %}
        cursor = self.conn.execute(
            "INSERT INTO {{ table_name }} DEFAULT VALUES RETURNING *",
        )
{% endif %}
        row = cursor.fetchone()
        if row is None:
            raise RuntimeError("Insert did not return a row")
        return {{ record_name }}(**dict(row))

{% if has_pk and non_pk_columns %}
    def update(
        self,
{%- for col in pk_columns %}
        {{ col.name }}: {{ col.base_type }},
{%- endfor %}
{%- for col in non_pk_columns %}
        {{ col.name }}: {{ col.update_type }} = UNSET,
{%- endfor %}
    ) -> {{ record_name }} | None:
        """Update a record."""
        set_clauses: list[sql.Composed] = []
        params: list[Any] = []
{% for col in non_pk_columns %}
        if {{ col.name }} is not UNSET:
            set_clauses.append(sql.SQL("{} = %s").format(sql.Identifier("{{ col.name }}")))
            params.append({{ col.name }})
{%- endfor %}

        if not set_clauses:
            return self.get_by_{% for col in pk_columns %}{{ col.name }}{% if not loop.last %}_and_{% endif %}{% endfor %}({% for col in pk_columns %}{{ col.name }}{% if not loop.last %}, {% endif %}{% endfor %})
{% for col in pk_columns %}
        params.append({{ col.name }})
{%- endfor %}

        query = sql.SQL("UPDATE {{ table_name }} SET {} WHERE {% for col in pk_columns %}{{ col.name }} = %s{% if not loop.last %} AND {% endif %}{% endfor %} RETURNING *").format(
            sql.SQL(", ").join(set_clauses)
        )

        cursor = self.conn.execute(query, params)
        row = cursor.fetchone()
        if row is None:
            return None
        return {{ record_name }}(**dict(row))

{% endif %}
{% if has_pk %}
    def delete(
        self,
{%- for col in pk_columns %}
        {{ col.name }}: {{ col.base_type }},
{%- endfor %}
    ) -> bool:
        """Delete a record. Returns True if deleted."""
        cursor = self.conn.execute(
            "DELETE FROM {{ table_name }} WHERE {% for col in pk_columns %}{{ col.name }} = %s{% if not loop.last %} AND {% endif %}{% endfor %}",
            ({% for col in pk_columns %}{{ col.name }},{% endfor %}),
        )
        return cursor.rowcount > 0

{% endif %}
{% if has_pk and not has_auto_generated_pk and non_pk_columns %}
    def upsert(
        self,
{%- for col in pk_columns %}
        {{ col.name }}: {{ col.base_type }},
{%- endfor %}
{%- for col in non_pk_columns %}
        {{ col.name }}: {{ col.update_type }} = UNSET,
{%- endfor %}
    ) -> {{ record_name }}:
        """Insert or update a record."""
        columns: list[sql.Identifier] = [{% for col in pk_columns %}sql.Identifier("{{ col.name }}"), {% endfor %}]
        values: list[Any] = [{% for col in pk_columns %}{{ col.name }}, {% endfor %}]
        update_clauses: list[sql.Composed] = []
{% for col in non_pk_columns %}
        if {{ col.name }} is not UNSET:
            columns.append(sql.Identifier("{{ col.name }}"))
            values.append({{ col.name }})
            update_clauses.append(sql.SQL("{} = EXCLUDED.{}").format(
                sql.Identifier("{{ col.name }}"),
                sql.Identifier("{{ col.name }}")
            ))
{%- endfor %}

        placeholders = sql.SQL(", ").join([sql.Placeholder()] * len(values))
        columns_sql = sql.SQL(", ").join(columns)

        if update_clauses:
            query = sql.SQL(
                "INSERT INTO {{ table_name }} ({}) VALUES ({}) "
                "ON CONFLICT ({% for col in pk_columns %}{{ col.name }}{% if not loop.last %}, {% endif %}{% endfor %}) DO UPDATE SET {} "
                "RETURNING *"
            ).format(columns_sql, placeholders, sql.SQL(", ").join(update_clauses))
        else:
            query = sql.SQL(
                "INSERT INTO {{ table_name }} ({}) VALUES ({}) "
                "ON CONFLICT ({% for col in pk_columns %}{{ col.name }}{% if not loop.last %}, {% endif %}{% endfor %}) DO NOTHING "
                "RETURNING *"
            ).format(columns_sql, placeholders)

        cursor = self.conn.execute(query, values)
        row = cursor.fetchone()

        if row is None:
            existing = self.get_by_{% for col in pk_columns %}{{ col.name }}{% if not loop.last %}_and_{% endif %}{% endfor %}({% for col in pk_columns %}{{ col.name }}{% if not loop.last %}, {% endif %}{% endfor %})
            if existing is None:
                raise RuntimeError("Upsert failed: record not found after conflict")
            return existing

        return {{ record_name }}(**dict(row))
{% endif %}

{% if insert_columns %}
    def bulk_insert(self, records: list[{{ singular_class_name }}InsertParams]) -> int:
        """Insert multiple records. Returns count inserted."""
        if not records:
            return 0

        columns = [{% for col in insert_columns %}"{{ col.name }}"{% if not loop.last %}, {% endif %}{% endfor %}]
        columns_sql = sql.SQL(", ").join([sql.Identifier(c) for c in columns])

        values: list[Any] = []
        placeholders_list: list[sql.Composed] = []

        for record in records:
            row_values = ({% for col in insert_columns %}record.{{ col.name }}, {% endfor %})
            values.extend(row_values)
            row_placeholders = sql.SQL("({})").format(
                sql.SQL(", ").join([sql.Placeholder()] * {{ insert_columns | length }})
            )
            placeholders_list.append(row_placeholders)

        query = sql.SQL("INSERT INTO {{ table_name }} ({}) VALUES {}").format(
            columns_sql,
            sql.SQL(", ").join(placeholders_list),
        )

        cursor = self.conn.execute(query, values)
        return cursor.rowcount

{% endif %}
{% if has_pk %}
    def bulk_delete(
        self,
{%- if pk_columns | length == 1 %}
        {{ pk_columns[0].name }}s: list[{{ pk_columns[0].base_type }}],
{%- else %}
        pks: list[tuple[{% for col in pk_columns %}{{ col.base_type }}{% if not loop.last %}, {% endif %}{% endfor %}]],
{%- endif %}
    ) -> int:
        """Delete multiple records by primary key. Returns count deleted."""
{%- if pk_columns | length == 1 %}
        if not {{ pk_columns[0].name }}s:
            return 0

        cursor = self.conn.execute(
            "DELETE FROM {{ table_name }} WHERE {{ pk_columns[0].name }} = ANY(%s)",
            (list({{ pk_columns[0].name }}s),),
        )
{%- else %}
        if not pks:
            return 0

        conditions: list[sql.Composed] = []
        params: list[Any] = []
        for pk in pks:
            condition = sql.SQL("({% for col in pk_columns %}{{ col.name }} = %s{% if not loop.last %} AND {% endif %}{% endfor %})")
            conditions.append(condition)
            params.extend(pk)

        query = sql.SQL("DELETE FROM {{ table_name }} WHERE {}").format(
            sql.SQL(" OR ").join(conditions)
        )
        cursor = self.conn.execute(query, params)
{%- endif %}
        return cursor.rowcount

{% endif %}
{% if has_pk and non_pk_columns %}
    def bulk_update(
        self,
{%- if pk_columns | length == 1 %}
        {{ pk_columns[0].name }}s: list[{{ pk_columns[0].base_type }}],
{%- else %}
        pks: list[tuple[{% for col in pk_columns %}{{ col.base_type }}{% if not loop.last %}, {% endif %}{% endfor %}]],
{%- endif %}
{%- for col in non_pk_columns %}
        {{ col.name }}: {{ col.update_type }} = UNSET,
{%- endfor %}
    ) -> int:
        """Update multiple records with the same values. Returns count updated."""
{%- if pk_columns | length == 1 %}
        if not {{ pk_columns[0].name }}s:
            return 0
{%- else %}
        if not pks:
            return 0
{%- endif %}

        set_clauses: list[sql.Composed] = []
        params: list[Any] = []
{% for col in non_pk_columns %}
        if {{ col.name }} is not UNSET:
            set_clauses.append(sql.SQL("{} = %s").format(sql.Identifier("{{ col.name }}")))
            params.append({{ col.name }})
{%- endfor %}

        if not set_clauses:
            return 0

{%- if pk_columns | length == 1 %}
        params.append(list({{ pk_columns[0].name }}s))

        query = sql.SQL("UPDATE {{ table_name }} SET {} WHERE {{ pk_columns[0].name }} = ANY(%s)").format(
            sql.SQL(", ").join(set_clauses)
        )
{%- else %}
        conditions: list[sql.Composed] = []
        for pk in pks:
            condition = sql.SQL("({% for col in pk_columns %}{{ col.name }} = %s{% if not loop.last %} AND {% endif %}{% endfor %})")
            conditions.append(condition)
            params.extend(pk)

        query = sql.SQL("UPDATE {{ table_name }} SET {} WHERE {}").format(
            sql.SQL(", ").join(set_clauses),
            sql.SQL(" OR ").join(conditions),
        )
{%- endif %}

        cursor = self.conn.execute(query, params)
        return cursor.rowcount

    def batch_update(self, updates: list[{{ singular_class_name }}UpdateParams]) -> int:
        """Update multiple records with individual values. Returns count updated."""
        if not updates:
            return 0

        updated_count = 0
        for update in updates:
            kwargs: dict[str, Any] = {
{%- for col in pk_columns %}
                "{{ col.name }}": update.{{ col.name }},
{%- endfor %}
            }
{%- for col in non_pk_columns %}
            if update.{{ col.name }} is not UNSET:
                kwargs["{{ col.name }}"] = update.{{ col.name }}
{%- endfor %}

            result = self.update(**kwargs)
            if result is not None:
                updated_count += 1

        return updated_count
{% endif %}
