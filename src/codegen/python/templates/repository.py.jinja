"""Repository class for {{ table_name }} table."""

from dataclasses import dataclass
from typing import Any
{% for imp in imports -%}
{{ imp }}
{% endfor -%}
from psycopg import Connection
from psycopg import sql

from ._types import UNSET, _Unset


@dataclass
class {{ record_name }}:
    """Record for {{ table_name }} table."""
{% for col in columns %}
    {{ col.name }}: {{ col.python_type }}
{%- endfor %}


class {{ class_name }}Repository:
    """Repository for {{ table_name }} operations."""

    def __init__(self, conn: Connection) -> None:
        self.conn = conn

{% if has_pk %}
    def get_by_{% for col in pk_columns %}{{ col.name }}{% if not loop.last %}_and_{% endif %}{% endfor %}(
        self,
{%- for col in pk_columns %}
        {{ col.name }}: {{ col.base_type }},
{%- endfor %}
    ) -> {{ record_name }} | None:
        """Get a record by primary key."""
        cursor = self.conn.execute(
            "SELECT * FROM {{ table_name }} WHERE {% for col in pk_columns %}{{ col.name }} = %s{% if not loop.last %} AND {% endif %}{% endfor %}",
            ({% for col in pk_columns %}{{ col.name }},{% endfor %}),
        )
        row = cursor.fetchone()
        if row is None:
            return None
        return {{ record_name }}(**dict(row))

{% endif %}
    def get_all(self) -> list[{{ record_name }}]:
        """Get all records."""
        cursor = self.conn.execute("SELECT * FROM {{ table_name }}")
        rows = cursor.fetchall()
        return [{{ record_name }}(**dict(row)) for row in rows]

    def insert(
        self,
{%- for col in insert_columns %}
        {{ col.name }}: {{ col.python_type }},
{%- endfor %}
    ) -> {{ record_name }}:
        """Insert a new record."""
{% if insert_columns %}
        cursor = self.conn.execute(
            """
            INSERT INTO {{ table_name }} ({% for col in insert_columns %}{{ col.name }}{% if not loop.last %}, {% endif %}{% endfor %})
            VALUES ({% for col in insert_columns %}%s{% if not loop.last %}, {% endif %}{% endfor %})
            RETURNING *
            """,
            ({% for col in insert_columns %}{{ col.name }}, {% endfor %}),
        )
{% else %}
        cursor = self.conn.execute(
            "INSERT INTO {{ table_name }} DEFAULT VALUES RETURNING *",
        )
{% endif %}
        row = cursor.fetchone()
        if row is None:
            raise RuntimeError("Insert did not return a row")
        return {{ record_name }}(**dict(row))

{% if has_pk and non_pk_columns %}
    def update(
        self,
{%- for col in pk_columns %}
        {{ col.name }}: {{ col.base_type }},
{%- endfor %}
{%- for col in non_pk_columns %}
        {{ col.name }}: {{ col.update_type }} = UNSET,
{%- endfor %}
    ) -> {{ record_name }} | None:
        """Update a record.
        
        Only fields with values other than UNSET are updated.
        Pass None explicitly to set a nullable field to NULL.
        """
        set_clauses: list[sql.Composed] = []
        params: list[Any] = []
{% for col in non_pk_columns %}
        if {{ col.name }} is not UNSET:
            set_clauses.append(sql.SQL("{} = %s").format(sql.Identifier("{{ col.name }}")))
            params.append({{ col.name }})
{%- endfor %}

        if not set_clauses:
            return self.get_by_{% for col in pk_columns %}{{ col.name }}{% if not loop.last %}_and_{% endif %}{% endfor %}({% for col in pk_columns %}{{ col.name }}{% if not loop.last %}, {% endif %}{% endfor %})
{% for col in pk_columns %}
        params.append({{ col.name }})
{%- endfor %}

        query = sql.SQL("UPDATE {{ table_name }} SET {} WHERE {% for col in pk_columns %}{{ col.name }} = %s{% if not loop.last %} AND {% endif %}{% endfor %} RETURNING *").format(
            sql.SQL(", ").join(set_clauses)
        )

        cursor = self.conn.execute(query, params)
        row = cursor.fetchone()
        if row is None:
            return None
        return {{ record_name }}(**dict(row))

{% endif %}
{% if has_pk %}
    def delete(
        self,
{%- for col in pk_columns %}
        {{ col.name }}: {{ col.base_type }},
{%- endfor %}
    ) -> bool:
        """Delete a record. Returns True if deleted."""
        cursor = self.conn.execute(
            "DELETE FROM {{ table_name }} WHERE {% for col in pk_columns %}{{ col.name }} = %s{% if not loop.last %} AND {% endif %}{% endfor %}",
            ({% for col in pk_columns %}{{ col.name }},{% endfor %}),
        )
        return cursor.rowcount > 0

{% endif %}
{% if has_pk and not has_auto_generated_pk and non_pk_columns %}
    def upsert(
        self,
{%- for col in pk_columns %}
        {{ col.name }}: {{ col.base_type }},
{%- endfor %}
{%- for col in non_pk_columns %}
        {{ col.name }}: {{ col.update_type }} = UNSET,
{%- endfor %}
    ) -> {{ record_name }}:
        """Insert or update a record.
        
        Only fields with values other than UNSET are included in the insert/update.
        Pass None explicitly to set a nullable field to NULL.
        """
        # Build column and value lists
        columns: list[sql.Identifier] = [{% for col in pk_columns %}sql.Identifier("{{ col.name }}"), {% endfor %}]
        values: list[Any] = [{% for col in pk_columns %}{{ col.name }}, {% endfor %}]
        update_clauses: list[sql.Composed] = []
{% for col in non_pk_columns %}
        if {{ col.name }} is not UNSET:
            columns.append(sql.Identifier("{{ col.name }}"))
            values.append({{ col.name }})
            update_clauses.append(sql.SQL("{} = EXCLUDED.{}").format(
                sql.Identifier("{{ col.name }}"),
                sql.Identifier("{{ col.name }}")
            ))
{%- endfor %}

        # Build placeholders
        placeholders = sql.SQL(", ").join([sql.Placeholder()] * len(values))
        columns_sql = sql.SQL(", ").join(columns)

        if update_clauses:
            query = sql.SQL(
                "INSERT INTO {{ table_name }} ({}) VALUES ({}) "
                "ON CONFLICT ({% for col in pk_columns %}{{ col.name }}{% if not loop.last %}, {% endif %}{% endfor %}) DO UPDATE SET {} "
                "RETURNING *"
            ).format(columns_sql, placeholders, sql.SQL(", ").join(update_clauses))
        else:
            query = sql.SQL(
                "INSERT INTO {{ table_name }} ({}) VALUES ({}) "
                "ON CONFLICT ({% for col in pk_columns %}{{ col.name }}{% if not loop.last %}, {% endif %}{% endfor %}) DO NOTHING "
                "RETURNING *"
            ).format(columns_sql, placeholders)

        cursor = self.conn.execute(query, values)
        row = cursor.fetchone()

        if row is None:
            existing = self.get_by_{% for col in pk_columns %}{{ col.name }}{% if not loop.last %}_and_{% endif %}{% endfor %}({% for col in pk_columns %}{{ col.name }}{% if not loop.last %}, {% endif %}{% endfor %})
            if existing is None:
                raise RuntimeError("Upsert failed: record not found after conflict")
            return existing

        return {{ record_name }}(**dict(row))
{% endif %}
